 {-# LANGUAGE NamedFieldPuns, TemplateHaskell, TransformListComp, ScopedTypeVariables, TypeFamilies, QuasiQuotes, TupleSections, NoMonomorphismRestriction, ViewPatterns, TypeSynonymInstances, FlexibleInstances, FlexibleContexts #-}
{-# OPTIONS -Wall -fno-warn-unused-imports -fno-warn-missing-signatures #-}

module Latexable.DD
        (latexifyDDResults,
         latexifySolSetConversionResult,
         enfunboxen, makeFunboxCommand,
         semicolonEvery7th, makeSemicolonBoxCommand,
         enfunboxenAndSemicolonEvery7th,
        )

    where

import Control.Arrow
import CoordSys
import Data.BitVector.Adaptive
import Data.List
import Data.List.Split(chunk)
import Data.Proxy
import Data.String.Interpolation
import FileLocation
import Latexable
import QuadCoordinates.SolSetConversion
import Triangulation
import TriangulationCxtObject
import VectorUtil
import VerboseDD
import qualified Data.Vector as V
import qualified Data.Vector.Generic as VG
import HomogenousTuples
import Util


renderPartitionBySignVariable :: Char -> Maybe Int -> [Char]
renderPartitionBySignVariable _sgn (mi :: Maybe Int) = 
    [str|S_{$[_sgn]$}|] ++ maybe "" (\i -> [str|^{($:i$)}|]) mi

debugBoxes = False

makebox width halign body = 
    (if debugBoxes then "\\framebox" else "\\makebox") ++ "["++width++"][" ++ halign ++"]{"++body++"}" 

makeFunboxCommand columnWidth body = 
    newcommand "\\funbox" 1 (makebox columnWidth "r" body)

makeSBoxCommand =
    newcommand "\\SBox" 1 (makebox "1em" "l" "#1") 


sbox = op1 "SBox" 

sboxWithPartitionBySignVariable name isEmpty =
                    sbox
                    (mathmode $
                    renderPartitionBySignVariable name Nothing
                    ++ if isEmpty
                        then " = \\emptyset"
                        else ":"
                        )

braces :: [Char] -> [Char]
braces x = "{"++x++"}"

-- | Requires 'makeFunboxCommand'.
enfunboxen :: (AsList xs, Latexable (Element xs)) => xs -> [Latex]
enfunboxen v = map (op1 "funbox") (asList v)

-- | Requires 'makeFunboxCommand' and 'makeSemicolonBoxCommand'.
enfunboxenAndSemicolonEvery7th = semicolonEvery7th True . enfunboxen . sd_toVector

pbs_pairWithDecriptiveChars pbs = zip [_S0 pbs, _Spos pbs, _Sneg pbs] "0+-"

renderPairFate
  :: (VerboseDDVectorRepresentation a co w) =>
     (a -> a -> [Char])
     -> Triangulation -> a -> a -> PairFateKind a -> [Char]
renderPairFate renderDDCombination tr u w k =
            case k of
                OK ix -> "OK, "++mathmode ix ++" := " 
                            ++ renderDDCombination u w

                NotAdjacent z -> "Nicht adjazent ("++mathmode ("z="++toLatex (ddrep_index z))++")"
                Incompatible -> "Inkompatibel (Bei Tetraeder "
                                    ++ toLatex ($fromJst (findTetViolatingQuadConstraints tr
                                                    (intersectZeroSets u w))) 
                                    ++ ")"

textBeforePairFates =
 
 "Einordnung der Elemente von $"
                        ++renderPartitionBySignVariable '+' Nothing
                        ++" \\times "
                        ++renderPartitionBySignVariable '-' Nothing
                        ++"$:"
                        ++nl

zeroSetComplElementsToLatex
  :: (BitVector w, CoordSys c) =>
     Proxy c -> Triangulation -> w -> [ Latex ]
zeroSetComplElementsToLatex co tr zs = 
    map (toLatex . discIndexToDisc co) $ zeroSetComplElements co tr zs 

maximum0 = maximum . (0:)


latexifyDDResults :: CoordSys co => 
       String -- ^ Column width
    -> DDResult co -> [Char]
latexifyDDResults columnWidth (DDResult tr steps final _ :: DDResult co) =


    braces (
        "% autogenerated\n"++
        makeFunboxCommand columnWidth "$#1$" ++ "\n" ++
        makeSBoxCommand ++
        latexEnvNL "description" (
        unlines (zipWith ddStepResultItem steps [0::Int ..])
        ++
        goFinal 
        )

    )


    where
        co = undefined :: Proxy co
--         g = length (hyperplanes co tr)
--         n = numberOfVariables co tr

        mkZeroSetBoxCmd ddreps = 
            let
                braceswidth_em = 1 :: Double
                commawidth_em = 1
                qwidth_em = 2.5

                _width = show width_em ++ "em" 
                    where
                        width_em = braceswidth_em + maximum0 (
                                do
                                    ddrep <- ddreps
                                    let qs = zeroSetComplElementsToLatex co tr . ddrep_zeroSet $ ddrep
                                        n = fi (length qs)
                                    return (qwidth_em * n  + commawidth_em * (n-1)))
            in
                newcommand "\\zerosetbox" 1 
                    (makebox _width "c" "$#1$" ++ "\n")

        ddStepResultItem (DDSR pbs pairFates) i =

            braces (
            "\\itemNL{Schritt $i="++show i++"$:}\n"++
            mkZeroSetBoxCmd (asList pbs) ++
            align (


--             array ("lcc":replicate (g-i) "r") 
                (unlineses $ map (goPartition i) (pbs_pairWithDecriptiveChars pbs))


                )
            ++
            if VG.null pairFates
               then ""
               else (textBeforePairFates++"\n" ++ goPairFates pairFates)
            )

        trailingAmps = "&&&"

        goPartition _ (signSet, name) =
           ("&" ++ sboxWithPartitionBySignVariable name (VG.null signSet) ++ "&&"++trailingAmps++"\\\\")
           :
           map goIPR (VG.toList signSet)

        goFinal =

            braces (
                mkZeroSetBoxCmd (asList final) ++
            "\\item[Ergebnis:]\n\n" ++

                tabular ["c","c","c"]
                 (header ++ "\\hline\n" ++ body)

            )
                where
                    header = "$v$ & $Z(v)$ &\\hspace{1.7em}Zurückgerechnete Q-Koordinaten von $v$\\\\\n" 

                    body = 
                      slashes
                        [
                        amps [ mathmode (ipr_index ipr)
                            , goZeroSet (zeroSet ipr)
                            , concat (enfunboxen (ipr_value ipr))
                            ]

                        |
                            ipr <- VG.toList final
                        ]
                    


        goIPR IPR {ipr_index,zeroSet,innerProducts} =

                    "&&"
                ++ toLatex ipr_index 
                ++ " &= "
                ++ "\\big(" 
                ++ goZeroSet zeroSet 
                ++ ", "
                ++ goInnerProducts innerProducts
                ++ "\\big)"++trailingAmps
                ++ "\\\\"



        goZeroSet = 
            op1 "zerosetbox" . op1 "overline" . latexSet . zeroSetComplElementsToLatex co tr
                

        goInnerProducts = concat . enfunboxen

        goPairFates pfs = 
                tabular ["l","@{,\\;}","r","l"]
                    (slashes (map goPair . VG.toList $ pfs))


        goPair (PairFate u w k) =
            mathmode ("(" ++ toLatex (ddrep_index u)) &
            (mathmode (       toLatex (ddrep_index w) ++ ")") ++ ":") &
            renderPairFate renderDDCombination tr u w k


        renderDDCombination u w =
                               mathmode (
                                   toLatex (w0 / (w0-u0))
                                ++ toLatex (ddrep_index u)
                                ++ plus (-u0 / (w0-u0))
                                ++ toLatex (ddrep_index w)
                                )
                    where
                        u0 = ipr_head u
                        w0 = ipr_head w



makeSemicolonBoxCommand = newcommand "\\semicolonbox" 1 (makebox "0.3em" "r" "#1")


-- | Requires 'makeSemicolonBoxCommand'
semicolonEvery7th :: Bool -> [Latex] -> Latex
semicolonEvery7th visible = 
              concat 
            . intercalate [ op1 "semicolonbox" (if visible then ";" else "") ++ "%\n" ] 
            . chunk 7 


columnIndicatorLeftShift = "0.60em" 
marginAdjust = "-2cm"
vspaceAfterPartialCanonicalPartAssigments = "1.1ex"
vspaceAfterTriStep = "2ex"
cSetOpenBraceLeftShift = "0.5em"
cSetClosingBraceRightShift = "0.3em"

solSetConversionVectorColumns = ["l","@{\\hspace{0.2em}}","c","@{\\hspace{-0.2em}}","l"]

latexifySolSetConversionResult ::
       String -- ^ Column width
    -> SolSetConversionResult Rational -> [Char]
latexifySolSetConversionResult columnWidth (SolSetConversionResult tr _ steps final _) =
    "% autogenerated\n"++

    braces (
        latexEnv "adjustwidth" ("{"++marginAdjust++"}{"++marginAdjust++"}\n" ++

        prelude ++ "\n" ++
        latexEnvNL "description" (
        unlines (zipWith goVertexStep steps [1::Int ..])
        ++
        goFinal 
        ++"\n"
        )

        )

    )


    where
        prelude =
            safeUnlines [
            makeFunboxCommand columnWidth "\\small $#1$",
            makeSBoxCommand ,
            makeSemicolonBoxCommand ,
            makeColumnIndicatorCommand
            ]



--         g = length (hyperplanes co tr)
--         n = numberOfVariables co tr



        goVertexStep vsr r =

            "\\itemNL{Äußerer Schritt $r="++show r++"$ (Ecke "++mathmode v++"):}" ++ nl
            ++ "\\\\" ++ nl
            ++ (latexEnv "math" . latexEnv "aligned" . concat . intercalate ["\\\\\n"] . chunk 4 
                       $ (partialCanonicalPartAssignments ++ 
                            [linkAssignment vsr_neglink "-" True])) ++ nl
            ++ vspace vspaceAfterPartialCanonicalPartAssigments
            ++ latexEnv "description"
                (unlines 
                    (zipWith 
                        (goTriStep r) 
                        (asList $ vsr_triStepResults vsr) 
                        [1::Int ..]))  
    
            ++ "Äußerer Schritt beendet; füge " ++ mathmode (linkAssignment vsr_link "" False) ++ " hinzu."

            
            where 
                v = "p("++toLatex (unT (vsr_vertex vsr))++")"
                partialCanonicalPartAssignment (i, j) = 
                    toLatex j ++ " &:= \\canonV^{("++v++")}("++toLatex i++")&"

                partialCanonicalPartAssignments = 
                    map partialCanonicalPartAssignment (VG.toList (vsr_partials vsr))

                linkAssignment accessor sign doAmps = let mbAmp = if doAmps then "&" else "" in 
                    toLatex (accessor vsr) ++ " "++mbAmp++":= "++sign++"\\scoord{\\vertexlink{"++v++"}}"
                        ++mbAmp


        goTriStep r (tsr@TriStepResult {tsr_pairFates=pairFates, tsr_tri=ntri}) s =
                "\\itemNL{Schritt $s="++show s++"$ (Normales Dreieck "++mathmode ntri++"):}"
            ++ "\n"
            ++
            tabular ( "l" : solSetConversionVectorColumns ) (
                (slashes $ 
                    goC r s (tsr_C_r_s1 tsr) : 
                    concatMap 
                        (goTriStepPartition ntri r s) 
                        (pbs_pairWithDecriptiveChars (tsr_pbs tsr))
                ))
            ++
            if VG.null pairFates
               then ""
               else (vspace "2ex" ++ "\\nopagebreak[3]" ++ "\\\\" ++ 
                    textBeforePairFates++  "\n" ++ goPairFates ntri pairFates)
            ++ nl ++ vspace vspaceAfterTriStep


        -- | Display the C-set
        goC r s _C = 

            amps [ sbox (mathmode ("C_{" ++ show r ++ "," ++ show (s-1) ++ "} =")) 
                 , ""
                 , makebox "0em" "l" (hspace cSetOpenBraceLeftShift ++ "\\{")
                 , "%\n" ++
                  (semicolonEvery7th False 
                    . enfunboxen 
                    . map (\x -> if null x then x else makebox "1em" "c" ("\\tiny" ++ x))
                    . addCommaToAllNonemptiesExceptLast (hspace "-0.1em" ++ ",")
                    . map (\d -> if bvUnsafeIndex _C (fromEnum d)
                                    then mathmode (veryBriefDiscType "-0.1em" d)
                                    else "")
                    $ tINormalDiscs tr
                    )
                    ++hspace cSetClosingBraceRightShift ++ "\\}"

                 ]



        goTriStepPartition ntri _ _ (signSet, name) =
           amps [ sboxWithPartitionBySignVariable name (VG.null signSet) 
                 , ""
                 , ""
                 ,
                        (if name=='0' then  "%\n" ++ columnIndicator else "") 
                    
                 ]
           :
           map (amps . ("":) . asList . goSSCVR) (VG.toList signSet)

               where
                    columnIndicator = 
                           semicolonEvery7th False 
                                (replicate 
                                    (fromEnum (iNormalTriToINormalDisc ntri)) 
                                    "\\funbox{}"
                                 ++ ["\\columnindicator"])


        makeColumnIndicatorCommand = 
            newcommand "\\columnindicator" 0 
                (op1 "funbox" 
                    (makebox columnIndicatorLeftShift "l" 
                        "\\tikz{\\node [draw,fill=gray,shape=dart,rotate=-90,scale=0.44] at (0,0) {};}"))

        goFinal =

            safeUnlines [
                    "\\itemNL{Ergebnis (Standard-Ecklösungsmenge):}",      
                    latexEnv "center" (
                    tabular ("l@{\\hspace{0.1em}}" : solSetConversionVectorColumns)
                        (slashes 
                            (map    
                                (amps . toList4 . goSSCRI ) 
                                (VG.toList final)))
                        )
                                      
                ]

            where
                goSSCRI (SolSetConversionResultItem i j v) = 
                    (
                      mathmode j 
                    , mathmode (":=" ++ op1 "projImage" i) 
                    , mathmode "="
                    ,  "%\n" ++ enfunboxenAndSemicolonEvery7th (adm_coords v)
                    ) 

        goSSCVR (SSCVR ix v) =
                 (
                   mathmode ix 
                 , mathmode "="
                 ,  "%\n" ++ enfunboxenAndSemicolonEvery7th v
                 ) 
                




        goPairFates (ntri :: INormalTri) pfs = 
                tabular ["l","@{,\\;}","r","l"]
                    (slashes (map goPair . VG.toList $ pfs))

            where
                goPair (PairFate u w k) =
                    mathmode ("(" ++ toLatex (ddrep_index u)) &
                    (mathmode (       toLatex (ddrep_index w) ++ ")") ++ ":") &
                    renderPairFate renderDDCombination tr u w k

                renderDDCombination u w =
                                    mathmode (
                                        toLatex (w0 / (w0-u0))
                                        ++ toLatex (ddrep_index u)
                                        ++ plus (-u0 / (w0-u0))
                                        ++ toLatex (ddrep_index w)
                                        )
                    where
                        u0 = triCount (unSSCVR u) ntri
                        w0 = triCount (unSSCVR w) ntri


addCommaToAllNonemptiesExceptLast comma xs =
    case break (not . null) (reverse xs) of
         (_,[]) -> xs 
         (ys,z0:zs) -> reverse (map (\z -> if null z then z else z++comma) zs) ++ (z0 : reverse ys)
    

